//Storage1.cpp
#include"Path.hpp"
#include"User.hpp"
#include"Meeting.hpp"
#include"Date.hpp"
#include"Storage.hpp"
#include<functional>
#include<string>
#include<iostream>
#include<list>
#include<fstream>
#include<memory>
#include<vector>
#include<functional>
using namespace std;
#define SIGNAL1
#define P
shared_ptr<Storage> Storage::m_instance = nullptr;
//int
Storage::Storage()
{ 
 // if(m_instance == nullptr)
   // m_instance(new Storage);
  m_dirty = false;
  readFromFile();
}

bool Storage::readFromFile(void) 
{
  ifstream fout(Path::meetingPath);
  ifstream foutu(Path::userPath);
  if(fout.is_open() == false)
   {
//    cout<<"wrong"<<endl;
   return false;}
  if(foutu.is_open() == false) 
    {
  //  cout<<"wrong"<<endl;
    return false;}
  string name;
  string pass;
  string mail;
  string phone;
  char ch;
//  int dc = 0;
  //while(!foutu.eof())
    while(1)
  {
/*    foutu>>ch;

    getline(foutu,name,'"');
    foutu>>ch;

    foutu>>ch;

    getline(foutu,pass,'"');
    foutu>>ch;

    foutu>>ch;

    getline(foutu,mail,'"');
    foutu>>ch;

    foutu>>ch;

    getline(foutu,phone,'"');

    foutu>>ch;

    if(!foutu.eof())
      foutu>>ch;
    User u(name,pass,mail,phone);
    m_userList.push_back(u);
    //cout<<dc++<<endl;
  */
  string str;
  getline(foutu,str);
  //cout<<str<<endl;
  vector<int> sign;
  int len = str.size();
  for(int index = 0; index < len ; index++)
  {
    if(str[index] == '"')
    sign.push_back(index);
  }
  if(sign.size() != 8)
    break;
   string name;
   string pass;
   string email;
   string phone;

   for(int index = sign[0]+1 ; index < sign[1] ; index++)
    name.push_back(str[index]);
   for(int index = sign[2]+1 ; index < sign[3] ; index++)
    pass.push_back(str[index]);
   for(int index = sign[4]+1 ; index < sign[5] ; index++)
    email.push_back(str[index]);
   for(int index = sign[6]+1 ; index < sign[7] ; index++)
    phone.push_back(str[index]);
  User u(name,pass,email,phone);
  m_userList.push_back(u);


  }
  //cout<<"break"<<endl;
  foutu.close();

  string spon;
  string temp_v;
  vector<string> v;
  string start;
  string end;
  string title;
  //while(!fout.eof())
  while(1)
  {
    /*fout>>ch;

    getline(fout,spon,'"');
    foutu>>ch;
    foutu>>ch;
    getline(fout,temp_v,'"');
    foutu>>ch;
    foutu>>ch;
    getline(fout,start,'"');
    foutu>>ch;
    foutu>>ch;
    getline(fout,end,'"');
    foutu>>ch;
    foutu>>ch;
    getline(fout,title,'"');
    vector<int> data;
    int len = temp_v.size();
    for(int index = 0 ; index < len ; index++ )
       if(temp_v[index] == '&')
         data.push_back(index);
    int leng = data.size()+1;
    for(int index = 0 ; index < leng ; index++ )
    {
      if(index == 0)
      {
      string str;
        for(int jndex = 0 ;jndex <= temp_v[index]-1; jndex++)
   str.push_back(temp_v[jndex]);
      v.push_back(str);
      continue;
      }
      if(index == leng - 1)
      { string str;
        for(int jndex = data[leng-2]+1 ; jndex < len ; jndex++)
   str.push_back(temp_v[jndex]);
 v.push_back(str);
 continue;


      }
      string str;
       for(int jndex = data[index-1]+1 ; jndex < data[index]; jndex++)
      str.push_back(temp_v[jndex]);
      v.push_back(str);

    }
    Date s(start), e(end);
    Meeting m(spon,v,s,e,title);
    m_meetingList.push_back(m);
    if(!fout.eof())
      fout>>ch;
    */
    vector<int> sign;
    vector<int> sep;
    //vector<int> par;
    string str;
    getline(fout,str);
    //cout<<str<<endl;
    vector<string> par;
    string spon;
    string startDate;
    string endDate;
    string title;
    int len = str.size();
    if(len<=2) break;
    //if(sign.size() != 10)
      //break;
    for(int index = 0 ; index < len ; index++)
    {
      if(str[index] == '"')
        sign.push_back(index);
      if(str[index] == '&')
        sep.push_back(index);
    }
    if(sign.size() < 2)
    break;
    for(int index = sign[0]+1 ; index < sign[1] ; index++)
      spon.push_back(str[index]);
    for(int index = sign[4]+1 ; index < sign[5] ; index++)
      startDate.push_back(str[index]);
    for(int index = sign[6]+1 ; index < sign[7] ; index++)
      endDate.push_back(str[index]);
    for(int index = sign[8]+1 ; index < sign[9] ; index++)
      title.push_back(str[index]);
    len = sep.size()+1;
    if(len != 1){
    for(int index = 0 ; index < len ; index++)
    {
      if(index == 0)
      {
        string ptr;
        for(int jndex = sign[2]+1 ; jndex < sep[index]; jndex++)
          ptr.push_back(str[jndex]);
        par.push_back(ptr);
        continue;
      }
      if(index == len - 1)
      {
        string ptr;
        for(int jndex = sep[index-1]+1 ; jndex < sign[3] ; jndex++)
          ptr.push_back(str[jndex]);
        par.push_back(ptr);
        continue;
      }
      string ptr;
      for(int jndex = sep[index-1]+1 ; jndex < sep[index] ; jndex++)
        ptr.push_back(str[jndex]);
      par.push_back(ptr);

    }}
    else
    {
       string htr;
       for(int jndex = sign[2]+1 ; jndex < sign[3] ; jndex++)
          htr.push_back(str[jndex]);
        par.push_back(htr);
    }
    Date b(startDate);
    Date e(endDate);
    Meeting m(spon,par,b,e,title);
    m_meetingList.push_back(m);
  }
  fout.close();
  return true;
}

bool Storage::writeToFile(void) 
{ // m_dirty = false;  

    m_dirty = false;
   fstream foutu(Path::userPath,ios::out);
   fstream fout(Path::meetingPath,ios::out);
  if(!fout.is_open())
{    
  // cout<<"wrong"<<endl;
return false;}
   if(!foutu.is_open())
 {
 // cout<<"fun"<<endl;
 return false;}
   int len1 = m_userList.size();
   int len2 = m_meetingList.size();
   //cout<<len1<<endl<<len2<<endl;
   if(len1 == 0 && len2 == 0)
       return false;

   //cout<<len1<<endl;
   auto it = m_userList.begin();
   //int count = 0;
   for(it ; it != m_userList.end(); it++)
   {
    //cout<<count++<<endl;
    foutu<<"\""<<(*it).getName()<<"\""<<','<<"\""<<(*it).getPassword()<<"\"";
    foutu<<','<<"\""<<(*it).getEmail()<<"\""<<','<<"\""<<(*it).getPhone()<<"\"";
  //  foutu<<"yes"<<endl;
  //  cout<<'"'<<(*it).getName()<<'"'<<','<<'"'<<(*it).getPassword()<<'"';
   // cout<<','<<(*it).getEmail()<<'"'<<','<<'"'<<(*it).getPhone()<<'"';
    auto itor = it;
    itor++;
    if(itor != m_userList.end())
      foutu<<"\n";
   }
   foutu.close();
   auto ft = m_meetingList.begin();
   for(ft; ft != m_meetingList.end() ; ft++)  
     {
       fout<<'"'<<(*ft).getSponsor()<<'"'<<','<<'"';
       vector<string> lenn = (*ft).getParticipator();
       int len = lenn.size();
       for(int index = 0 ; index < len ; index++)
       {
         fout<<lenn[index];
  if(index != len-1)
  fout<<'&';
       }
       fout<<'"'<<',';
       fout<<'"'<<(*ft).getStartDate().dateToString((*ft).getStartDate())<<'"';
       fout<<','<<'"'<<(*ft).getEndDate().dateToString((*ft).getEndDate())<<'"'<<','<<'"'<<(*ft).getTitle()<<'"';
       auto ftor = ft;
       ftor++;
       if(ftor != m_meetingList.end())
         fout<<"\n";
     }
     fout.close();
     return true;
}
shared_ptr<Storage> Storage::getInstance(void) 
{    if(m_instance == nullptr)
        m_instance =  shared_ptr<Storage> (new Storage());
     //cout<<"fun"<<endl;
     return m_instance;
}
Storage::~Storage()
{
     sync();
}

void Storage::createUser(const User& other)
{
    m_userList.push_back(other);
   // auto it = m_userList.begin();
    //for(it ; it != m_userList.end() ; it++)
    //{
      //cout<<it->getName()<<" "<<it->getPassword()<<" "<<it->getPhone()<<" "<<it->getEmail()<<endl;
    //}
    m_dirty = true;
}
list<User> Storage::queryUser(std::function<bool(const User &)> filter) const
{   list<User> v;
    auto itor = m_userList.begin();
    for(itor;itor!= m_userList.end() ; itor++)
    {
      if(filter(*itor))
        v.push_back(*itor);
    }
    return v;
}
int Storage::updateUser(function<bool (const User &)> filter, function<void(User &)> switcher)
{  int count = 0;
   auto itor = m_userList.begin();
   for(itor ; itor != m_userList.end() ; itor++)  
     {
       if(filter(*itor))
       {
         switcher(*itor);
  count++;
       }
     }
     if(count != 0)
     m_dirty = true;
   return count;
}

int Storage::deleteUser(function<bool(const User &)> filter)
{
  auto itor = m_userList.begin();
  int count = 0;
  for(itor;itor != m_userList.end() ; )
  {
    if(filter(*itor))  
    {
     auto it = itor;
     itor = m_userList.erase(it);
     count++;
     continue;
    }
    itor++;
  }
  if(count != 0)
  m_dirty = true;
  return count;
}

list<Meeting> Storage::queryMeeting(function<bool(const Meeting&)> filter) const
{
  list<Meeting> m;
  auto itor = m_meetingList.begin();
  for(itor ; itor != m_meetingList.end(); itor++)
  {
    if(filter(*itor))
      m.push_back(*itor);
  }
  return m;
}
int Storage::updateMeeting(function<bool (const Meeting&)> filter, function<void(Meeting&)> switcher)
{
  int count = 0;
  auto itor = m_meetingList.begin();
  for(itor;itor != m_meetingList.end(); itor++)
    {
      if(filter(*itor))
      {
        switcher(*itor);
 count++;
      }
    }
    if(count != 0)
    m_dirty = true;
  return count;
}
void Storage::createMeeting(const Meeting& t_m)
{
    m_meetingList.push_back(t_m);
    m_dirty=true;
}
int Storage::deleteMeeting(function<bool(const Meeting&)> filter)
{
    int count = 0;
    auto itor = m_meetingList.begin();
    for(itor;itor!= m_meetingList.end(); )
    {
       if(filter(*itor))
       {
        count++;
        auto it = itor;
        //it++;
        itor = m_meetingList.erase(it);
        continue;
       }
       itor++;
    }
    if(count != 0)
    m_dirty = true;
    return count;
}
bool Storage::sync()
{ //  cout<<boolalpha<<m_dirty<<endl;
    if(m_dirty == false) return false;
    if(m_dirty == true)
    {

      bool flag1 = writeToFile();
      if(flag1 == false)
        return false;
    }
    //m_dirty = false; 
    return true;
}



//storage2.cpp
#ifndef __STORAGE_H__
#define __STORAGE_H__

#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
  TypeName(const TypeName&); \
  void operator=(const TypeName&)

#include <list>
#include <string>
#include <functional>
#include <fstream>
#include <iostream>

#include "User.h"
#include "Meeting.h"
using namespace std;

class Storage {
    private:
        static Storage *instance_;
        DISALLOW_COPY_AND_ASSIGN(Storage);
        Storage() {
            readFromFile("agenda.data");
        }
        // storage structure with list, or you have better structures
        // e.g. balanced tree
        std::list<User> userList_;
        std::list<Meeting> meetingList_;
        // File IO
        bool readFromFile(const char *fpath) {
            ifstream fin(fpath);
            if (!fin.is_open())
                return false;
            int userCount, meetingCount;
            string str;
            stringstream ss;
            fin >> str;
            str = str.substr(str.find("total:") + 6);
            ss << str;
            ss >> userCount;
            ss.str("");
            for (int i = 0; i < userCount; i++) {
                fin >> str;
                userList_.push_back(JSONToUser(str));
            }

            fin >> str;
            str = str.substr(str.find("total:") + 6);
            ss << str;
            ss >> meetingCount;
            for (int i = 0; i < meetingCount; i++) {
                fin >> str;
                meetingList_.push_back(JSONToMeeting(str));
            }
            return true;
        }
        bool writeToFile(const char *fpath) {
            ofstream fout(fpath);
            if (!fout.is_open())
                return false;
            fout << "{colletion:\"User\",total:" << userList_.size() << "}\n";
            for (auto itr = userList_.begin(); itr != userList_.end(); itr++) {
                fout << UserToJSON(*itr) << endl;
            }
            fout << "{colletion:\"Meeting\",total:" << meetingList_.size() << "}\n";
            for (auto itr = meetingList_.begin(); itr != meetingList_.end(); itr++) {
                fout << MeetingToJSON(*itr) << endl;
            }
            return true;
        }
        string UserToJSON(const User& user) {
            stringstream ss;
            ss << "{name:" << "\"" << user.getName() << "\","
               << "password:" << "\"" << user.getPassWord() << "\","
               << "email:" << "\"" << user.getEmail() << "\","
               << "phone:" << "\"" << user.getPhone() << "\"}";
            return ss.str();
        }
        string MeetingToJSON(const Meeting& meeting) {
            stringstream ss;
            ss << "{sponsor:" << "\"" << meeting.getSponsor() << "\","
               << "partipator:" << "\"" << meeting.getParticipator() << "\","
               << "sdate:" << "\"" << Date::dateToString(meeting.getStartDate()) << "\","
               << "edate:" << "\"" << Date::dateToString(meeting.getEndDate()) << "\","
               << "title:" << "\"" << meeting.getTitle() << "\"}";
            return ss.str();
        }
        User JSONToUser(const string& json) {
            string name, password, email, phone;
            int pos, len;
            pos = json.find("name:\"") + 6;
            len = json.find("\",password") - pos;
            name = json.substr(pos, len);
            pos = json.find("password:\"") + 10;
            len = json.find("\",email") - pos;
            password = json.substr(pos, len);
            pos = json.find("email:\"") + 7;
            len = json.find("\",phone") - pos;
            email = json.substr(pos, len);
            pos = json.find("phone:\"") + 7;
            len = json.find("\"}") - pos;
            phone = json.substr(pos, len);
            return User(name, password, email, phone);
        }
        Meeting JSONToMeeting(const string& json) {
            string sponsor, partipator, sdate, edate, title;
            int pos, len;
            pos = json.find("sponsor:\"") + 9;
            len = json.find("\",partipator") - pos;
            sponsor = json.substr(pos, len);
            pos = json.find("partipator:\"") + 12;
            len = json.find("\",sdate") - pos;
            partipator = json.substr(pos, len);
            pos = json.find("sdate:\"") + 7;
            len = json.find("\",edate") - pos;
            sdate = json.substr(pos, len);
            pos = json.find("edate:\"") + 7;
            len = json.find("\",title") - pos;
            edate = json.substr(pos, len);
            pos = json.find("title:\"") + 7;
            len = json.find("\"}") - pos;
            title = json.substr(pos, len);
            return Meeting(sponsor, partipator,
                Date::stringToDate(sdate), Date::stringToDate(edate), title);
        }
    public:
        // singleton
        static Storage *getInstance(void) {
            if (instance_ == nullptr)
                instance_ = new Storage();
            return instance_;
        }
        ~Storage() {}
        // CRUD for User & Meeting
        // using C++11 Function Template and Lambda Expressions
        void createUser(const User& user) {
            userList_.push_back(user);
        }
        std::list<User> queryUser(std::function<bool(const User&)> filter) {
            list<User> returnList;
            for (auto itr = userList_.begin(); itr != userList_.end(); itr++) {
                if (filter(*itr)) {
                    returnList.push_back(*itr);
                }
            }
            return returnList;
        }
        // return found users
        int updateUser(std::function<bool(const User&)> filter,
                       std::function<void(User&)> switcher) {
            int count = 0;
            for (auto itr = userList_.begin(); itr != userList_.end(); itr++) {
                if (filter(*itr)) {
                    switcher(*itr);
                    count++;
                }
            }
            return count;
        }
        // return the number of updated users
        int deleteUser(std::function<bool(const User&)> filter) {
            int count = 0;
            for (auto itr = userList_.begin(); itr != userList_.end(); itr++) {
                if (filter(*itr)) {
                    userList_.push_back(*itr);
                    count++;
                }
            }
            return count;
        }
        // return the number of deleted users
        void createMeeting(const Meeting& meeting) {
            meetingList_.push_back(meeting);
        }
        std::list<Meeting> queryMeeting(
                       std::function<bool(const Meeting&)> filter) {
            list<Meeting> returnList;
            for (auto itr = meetingList_.begin(); itr != meetingList_.end(); itr++) {
                if (filter(*itr)) {
                    returnList.push_back(*itr);
                }
            }
            return returnList;
        }
        // return found meetings
        int updateMeeting(std::function<bool(const Meeting&)> filter,
            std::function<void(Meeting&)> switcher) {
            int count = 0;
            for (auto itr = meetingList_.begin(); itr != meetingList_.end(); itr++) {
                if (filter(*itr)) {
                    switcher(*itr);
                    count++;
                }
            }
            return count;
        }
        // return the number of updated meetings
        int deleteMeeting(std::function<bool(const Meeting&)> filter) {
            int count = 0;
            for (auto itr = meetingList_.begin(); itr != meetingList_.end(); itr++) {
                if (filter(*itr)) {
                    meetingList_.erase(itr);
                    count++;
                }
            }
            return count;
        }
        // return the number of deleted meetings
        // File IO
        bool sync(void) {
            return writeToFile("agenda.data");
        }
};
Storage* Storage::instance_ = nullptr;
#endif





//storage18

#include "Storage.hpp"

#include "Path.hpp"

#include <fstream>

using namespace std;

std::shared_ptr<Storage> Storage::m_instance = nullptr;

Storage::Storage() {

	m_dirty = false;

	readFromFile();

};

bool Storage::readFromFile(void) {

	ifstream fusers(Path::userPath);

	ifstream fmeetings(Path::meetingPath);

	if (!(fusers.is_open() && fmeetings.is_open())){

		return false;

	}

	string str1;

	while (getline(fusers, str1)) {

		string name, password, email, phone;

		if(str1.size() == 0) {

            continue;

        }

        int len=str1.size();

        vector<int>pos;

		for(int i = 0; i < len ; i++){

    		if(str1[i] == '"')

    		pos.push_back(i);

  		}

		for(int i = pos[0]+1 ; i < pos[1] ; i++){

			name.push_back(str1[i]);

		}	

   		for(int i = pos[2]+1 ; i < pos[3] ; i++){

   			password.push_back(str1[i]);

		}

   		for(int i = pos[4]+1 ; i < pos[5] ; i++){

   			email.push_back(str1[i]);

		}

   		for(int i = pos[6]+1 ; i < pos[7] ; i++){

   			phone.push_back(str1[i]);

		}

		User u(name, password, email, phone);

		m_userList.push_back(u);

	}

	fusers.close();

	string str2;

	while (getline(fmeetings, str2)) {

		string sponsor, participators, startDate, endDate, title;

		if(str2.size() == 0) {

                continue;

        }

		int len=str2.size();

		vector<int> pos;

		for(int i = 0; i < len ; i++){

    		if(str2[i] == '"')

    		pos.push_back(i);

  		}

  			for(int i = pos[0]+1 ; i < pos[1] ; i++){

				sponsor.push_back(str2[i]);

			}

			for(int i = pos[2]+1 ; i < pos[3] ; i++){

				participators.push_back(str2[i]);

			}

    		for(int i = pos[4]+1 ; i < pos[5] ; i++){

				startDate.push_back(str2[i]);

			}	

    		for(int i = pos[6]+1 ; i < pos[7] ; i++){

				endDate.push_back(str2[i]);

			}

    		for(int i = pos[8]+1 ; i < pos[9] ; i++){

				title.push_back(str2[i]);

			}

		vector<string> v_participators;

		int len2=participators.size();

		string parti;

		for(int i=0;i<len2;i++){

			if(participators[i]!='&'){

				parti.push_back(participators[i]);

			}

			else{

				string temp=parti;

				v_participators.push_back(temp);

				parti.clear();

			}

		}

		v_participators.push_back(parti);

		Date start(startDate);

		Date end(endDate);

		Meeting meeting(sponsor, v_participators, start, end, title);

		m_meetingList.push_back(meeting);

	}

	fmeetings.close();

	return true;

};

bool Storage::writeToFile(void) {

	ofstream fusers(Path::userPath);

	ofstream fmeetings(Path::meetingPath);

	if (!(fusers.is_open() && fmeetings.is_open())){

		return false;

	}

	for (auto it = m_userList.begin();it != m_userList.end();it++) {

		fusers<<'"'<<(*it).getName()<<'"'<<','<<'"'<<(*it).getPassword()<<'"'<<','<<'"'<<(*it).getEmail()<<'"'<<','<<'"'<<(*it).getPhone()<<'"';

		fusers<<"\n";

	}

	fusers.close();

   	for(auto it = m_meetingList.begin();it != m_meetingList.end();it++)  {

       fmeetings<<'"'<<(*it).getSponsor()<<'"'<<','<<'"';

       vector<string> par = (*it).getParticipator();

       int len = par.size();

       for(int i = 0 ; i < len-1 ; i++){

         	fmeetings<<par[i]<<'&';

       }

       fmeetings<<par[len-1];

       fmeetings<<'"'<<','<<'"'<<(*it).getStartDate().dateToString((*it).getStartDate())<<'"'<<','<<'"'<<(*it).getEndDate().dateToString((*it).getEndDate())<<'"'<<','<<'"'<<(*it).getTitle()<<'"';

         fmeetings<<"\n";

     }

	fmeetings.close();

	return true;

};

std::shared_ptr<Storage> Storage::getInstance(void) {

	if (m_instance == nullptr) {

		m_instance = shared_ptr<Storage>(new Storage());

	}

	return m_instance;

};

Storage::~Storage() {

	sync();

};

void Storage::createUser(const User &t_user) {

	m_userList.push_back(t_user);

	m_dirty = true;

};

std::list<User> Storage::queryUser(std::function<bool(const User &)> filter) const {

	std::list<User> result;

	for (auto it = m_userList.begin();it != m_userList.end();it++) {

		if (filter(*it)){

			result.push_back(*it);

		}

	}

	return result;

};

int Storage::updateUser(std::function<bool(const User &)> filter,

             std::function<void(User &)> switcher) {

	int num = 0;

	for (auto it = m_userList.begin();it != m_userList.end();it++) {

		if (filter(*it)) {

			switcher(*it);

			num++;

		}

	}

	if(num > 0){

		m_dirty = true;

	}

	return num;

};

int Storage::deleteUser(std::function<bool(const User &)> filter) {

	int num = 0;

	for (auto it = m_userList.begin();it != m_userList.end();) {

		if (filter(*it)) {

			it = m_userList.erase(it);

			num++;

		}

		else{

			it++;

		}

	}

	if (num > 0){

		m_dirty = true;

	}

	return num;

};

void Storage::createMeeting(const Meeting &t_meeting) {

	m_meetingList.push_back(t_meeting);

	m_dirty = true;

};

std::list<Meeting> Storage::queryMeeting(

  std::function<bool(const Meeting &)> filter) const {

	list<Meeting> meeting;

	for (auto it = m_meetingList.begin();it != m_meetingList.end();it++) {

		if (filter(*it))

			meeting.push_back(*it);

	}

	return meeting;

};

int Storage::updateMeeting(std::function<bool(const Meeting &)> filter,

                std::function<void(Meeting &)> switcher) {

	int num = 0;

	for (auto it = m_meetingList.begin();it != m_meetingList.end();it++) {

		if (filter(*it)) {

			switcher(*it);

			num++;

		}

	}

	if (num > 0){

		m_dirty = true;

	}

	return num;

};

int Storage::deleteMeeting(std::function<bool(const Meeting &)> filter) {

	int num = 0;

	for (auto it = m_meetingList.begin();it != m_meetingList.end();) {

		if (filter(*it)) {

			it = m_meetingList.erase(it);

			num++;

		}

		else

			it++;

	}

	if (num > 0){

		m_dirty = true;

	}

	return num;

};

bool Storage::sync(void) {

	m_dirty = false;

	return writeToFile();

};






//my_storage
//static std::shared_ptr<Storage> m_instance;
//  std::list<User> m_userList;
//  std::list<Meeting> m_meetingList;
//  bool m_dirty;

//#include"Path.hpp"
//#include"User.hpp"
//#include"Meeting.hpp"
//#include"Date.hpp"
//#include"Storage.hpp"
#include<functional>
#include<string>
#include<iostream>
#include<list>
#include<fstream>
#include<memory>
#include<vector>
#include<functional>
using namespace std;
//#define SIGNAL1
//#define P
shared_ptr<Storage> Storage::m_instance = nullptr;

Storage::Storage()
{
	m_dirty = false;
	readFromFile();
}

bool Storage::readFromFile(void)
{
	ifstream fusers(Path::meetingPath);
	ifstream fmeetings(Path::userPath);
	if(fusers.is_open() == false)
		return false;
	if(fmeetings.is_open() == false)
		return false;
	
	string str1;
	while(getline(fusers, str1))
	{
		string name, password, email, phone;
		if(str1.size() == 0)
			continue;
		
		int len = str1.size();
		vector<int> pos;
		for(int i = 0; i < len; ++i)
			if(str[i] == '"')
				pos.push_back(i);
		
		for(int i = pos[0] + 1; i < pos[1]; ++i)
			name.push_back(str[i]);
			
		for(int i = pos[2] + 1; i < pos[3]; ++i)
			password.push_back(str[i]);
			
		for(int i = pos[4] + 1; i < pos[5]; ++i)
			email.push_back(str[i]);
			
		for(int i = pos[6] + 1; i < pos[7]; ++i)
			phone.push_back(str[i]);
			
		User u(name, password, email, phone);
		m_userList.push_back(u);
	}
	fusers.close();
	
	string str2;
	while(hetline(fmeetings, str2))
	{
		string sponsor, participators, startDate, endDate, title;
		if(str2.size() == 0)
			continue;
			
		int len = str2.size();
		vector<int> pos;
		for(int i = 0; i < len; ++i)
			if(str2[i] == '"')
				pos.push_back(i);
				
		for(int i = pos[0]+1 ; i < pos[1] ; i++)
			sponsor.push_back(str2[i]);
		
		for(int i = pos[2]+1 ; i < pos[3] ; i++)
			participators.push_back(str2[i]);
			
		for(int i = pos[4]+1 ; i < pos[5] ; i++)
			startDate.push_back(str2[i]);
		
		for(int i = pos[6]+1 ; i < pos[7] ; i++)
			endDate.push_back(str2[i]);
			
		for(int i = pos[8]+1 ; i < pos[9] ; i++)
			title.push_back(str2[i]);
		
		vector<string> v_participators;
		int len2 = participators.size();
		string parti;
		for(int i = 0; i < len2; ++i)
		{
			if(participators[i] != '&')
				parti.push_back(participators[i]);
			else
			{
				string temp = parti;
				v_participators.push_back(temp);
				parti.clear();
			}
		}
		v_participators.push_back(parti);
		Date start(startDate);
		Date end(endDate);
		Meeting meeting(sponsor, v_participators, start, end, title);
		m_meetingList.push_back(meeting);
	}
	fmeetings.close();
	return true;
}

bool Storage::writeToFile(void)
{
	ofstream fusers(Path::userPath);
	ofstream fmeetings(Path::meetingPath);
	if(!(fusers.is_open() && fmeetings.is_open()))
		return false;
	
	for(auto it = m_userList.begin(); it != m_userList.end(); ++i)
	{
		fusers << '"' << (*it).getName() << '"' << ',' << '"' << (*it).getPassword() << '"' << ',' << '"' << (*it).getEmail() << '"' << ',' << '"' << (*it).getPhone() << '"';
		fusers << "\n";
	}
	fusers.close();
	
	for(auto it = m_meetingList.begin(); it != m_meetingList.end(); it++)
	{
        fmeetings << '"' << (*it).getSponsor() << '"' << ',' << '"';
        vector<string> par = (*it).getParticipator();

        int len = par.size();
        for(int i = 0; i < len-1; i++)
         	fmeetings << par[i]<<'&';

        fmeetings << par[len-1];
        fmeetings << '"' << ',' << '"' << (*it).getStartDate().dateToString((*it).getStartDate()) << '"' << ',' << '"' << (*it).getEndDate().dateToString((*it).getEndDate()) << '"' << ',' << '"' << (*it).getTitle() << '"';
        fmeetings << "\n";
    }
    fmeetings.close();
    return true;
}

std::shared_ptr<Storage> Storage::getInstance(void)
{
	if(m_instance == nullptr)
		m_instance = shard_ptr<Storage> (new Storage());
	
	return m_instance;
}

Storage::~Storage()
{
     sync();
}

void Storage::createUser(const User &t_user)
{
	m_userList.push_back(t_user)
	m_dirty = true;
}

list<User> Storage::queryUser(std::function<bool(const User &)> filter) const
{
	list<User> v;
	auto itor = m_userList.begin();
	for(itor; itor != m_userList.end(); ++itor)
	{
		if(filter(*itor))
			v.push_back(*itor);
	}
	return v;
}

int Storage::updateUser(std::function<bool(const User &)> filter,
                 std::function<void(User &)> switcher)
{
	int count = 0;
	auto itor = m_userList.begin();
	for(itor; itor != m_userList.end(); itor++)
	{
		if(filter(*itor))
		{
			switcher(*itor);
			count++;
		}
	}
	if(count != 0)
		m_dirty = true;
	return count;
}

int Storage::deleteUser(std::function<bool(const User &)> filter)
{
	auto itor = m_userList.begin();
	int count = 0;
	for(itor; itor != m_userList.end(); )
	{
		if(filter(*itor))
		{
			auto it = itor;
			itor = m_userList.erase(it);
			count++;
			continue;
		}
		itor++;
	}
	if(count != 0)
		m_dirty = true;
	return count;
}

void Storage::createMeeting(const Meeting &t_meeting)
{
	m_meetingList.push_back(t_meeting);
	m_dirty = true;
}

list<Meeting> Storage::queryMeeting(function<bool(const Meeting &)> filter) const
{
	list<Meeting> m;
	auto itor = m_meetingList.begin();
	for(itor; itor != m_meetingList.end(); ++itor)
	{
		if(filter(*itor))
			m.push_back(*itor);
	}
	return m;
}

int Storage::updateMeeting(function<bool(const Meeting &)> filter,
                    function<void(Meeting &)> switcher)
{
	int count = 0;
	auto itor = m_meetingList.begin();
	for(itor; itor != m_meetingList.end(); itor++)
	{
		if(filter(*itor))
		{
			switcher(*itor);
			count++;
		}
	}
	if(count != 0)
		m_dirty = true;
	return count;
}

int Storage::deleteMeeting(function<bool(const Meeting &)> filter)
{
	auto itor = m_meetingList.begin();
	int count = 0;
	for(itor; itor != m_meetingList.end(); )
	{
		if(filter(*itor))
		{
			auto it = itor;
			itor = m_meetingList.erase(it);
			count++;
			continue;
		}
		itor++;
	}
	if(count != 0)
		m_dirty = true;
	return count;
}

bool Storage::sync(void)
{
	if(m_dirty == false)
		return false;
	if(m_dirty == true)
	{
		bool flag = writeToFile();
		if(flag == false)
			return false;
	}
	return true;
}
